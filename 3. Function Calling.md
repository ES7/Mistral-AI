# Function Calling
Function calling allows mistral models to connect to external tools making it easy for us to build applicaitons catering to specific use cases and practical problems.

At high levels there are four steps with function calling:<br>
1. For users to define tools and use a query. A tool can be a user defined function or an external API. For example, users can write two functions to extract the payment status and payment date information, and then when the user asks a question, what's the status of my payment? This question is directly related to the payment status tool, and we should use this tool to address the question.<br>
2. For a mistral model to generate function arguments. When applicable, based on the tools and the user query, our model is able to determine that the function we should use is payment status and the function argument is transaction ID equals T1001.<br>
3. For users to execute the function to obtain two results. We simply pass the function arguments directly in the function, and we get the result from the function which is paid in this example.<br>
4. For a model to generate a final answer according to the information available, your transaction ID T1001 has been paid. Is there anything else I can assist you with?<br>

```python
!pip install pandas "mistralai>=0.1.2"
```
```python
import pandas as pd
from helper import load_mistral_api_key
api_key, dlai_endpoint = load_mistral_api_key(ret_key=True)
```

```python
data = {
    "transaction_id": ["T1001", "T1002", "T1003", "T1004", "T1005"],
    "customer_id": ["C001", "C002", "C003", "C002", "C001"],
    "payment_amount": [125.50, 89.99, 120.00, 54.30, 210.20],
    "payment_date": [
        "2021-10-05",
        "2021-10-06",
        "2021-10-07",
        "2021-10-05",
        "2021-10-08",
    ],
    "payment_status": ["Paid", "Unpaid", "Paid", "Paid", "Pending"],
}
df = pd.DataFrame(data)

transaction_id = "T1001"

prompt = f"""
Given the following data, what is the payment status for \
 transaction_id={transaction_id}?

data:
{data}
"""
```
To ask questions about this data without function calling, we could simplly pass this data in the prompt and then ask the question. Given the following: "data what is the payment status for the transaction ID, which is T1001?".
```python
import os
from mistralai.client import MistralClient
from mistralai.models.chat_completion import ChatMessage


def mistral(user_message, model="mistral-small-latest", is_json=False):
    client = MistralClient(api_key=api_key, endpoint=dlai_endpoint)
    messages = [ChatMessage(role="user", content=user_message)]

    if is_json:
        chat_response = client.chat(
            model=model, messages=messages, response_format={"type": "json_object"}
        )
    else:
        chat_response = client.chat(model=model, messages=messages)

    return chat_response.choices[0].message.content
```
```python
response = mistral(prompt)
print(response)
```
`OUTPUT --> The payment status for transaction_id=T1001 is "Paid".`<br>
In real use cases we have huge number of transactions and passing this amount of data may exceed the context window size. A more efficient, affordable and reliable way to do this is to use function calling to run the code. To perform this kind of search. We just need to prompt the LLM to know when to call each function.

### 1. User: specify tools and query
First define all the necessary tools for users use cases.
```python
import json
def retrieve_payment_status(df: data, transaction_id: str) -> str:
    if transaction_id in df.transaction_id.values:
        return json.dumps(
            {"status": df[df.transaction_id == transaction_id].payment_status.item()}
        )
    return json.dumps({"error": "transaction id not found."})
```
```python
status = retrieve_payment_status(df, transaction_id="T1001")
print(status)
```
`OUTPUT --> {"status": "Paid"}`<br>
For example here we have a function retrieve payment status. If we define the function argument, transaction ID is T1001. We get the status paid from this function.

```python
def retrieve_payment_date(df: data, transaction_id: str) -> str:
    if transaction_id in df.transaction_id.values:
        return json.dumps(
            {"date": df[df.transaction_id == transaction_id].payment_date.item()}
        )
    return json.dumps({"error": "transaction id not found."})
```
```python
date = retrieve_payment_date(df, transaction_id="T1002")
print(date)
```
`OUTPUT --> {"date": "2021-10-06"}`<br>
We have another example, we can retrieve the payment date information based on a transaction ID. And then we get the date.

So how do Mistral models understand these functions?. For these models to understand these function we can align the function specs with a JSON schema.
```python
tool_payment_status = {
    "type": "function",
    "function": {
        "name": "retrieve_payment_status",
        "description": "Get payment status of a transaction",
        "parameters": {
            "type": "object",
            "properties": {
                "transaction_id": {
                    "type": "string",
                    "description": "The transaction id.",
                }
            },
            "required": ["transaction_id"],
        },
    },
}
```
This is the JSON schema for the function retrieve payment status. Specify the tool type  which has a function in this case, the function name. The function description. This will tell the model. What does this function do. The parameters of the function, which includes the argument of the function. The type of the argument and the description of the argument. Also specify the required function argument, which is the transaction ID here. 
```python
tool_payment_date = {
    "type": "function",
    "function": {
        "name": "retrieve_payment_date",
        "description": "Get payment date of a transaction",
        "parameters": {
            "type": "object",
            "properties": {
                "transaction_id": {
                    "type": "string",
                    "description": "The transaction id.",
                }
            },
            "required": ["transaction_id"],
        },
    },
}
```
Similarly define the JSON schema for retrieve payment date.
```python
tools = [tool_payment_status, tool_payment_date]
```
Then combine both the JSON specs into a list called tools.

### functools
```python
import functools
names_to_functions = {
    "retrieve_payment_status": functools.partial(retrieve_payment_status, df=df),
    "retrieve_payment_date": functools.partial(retrieve_payment_date, df=df),
}
names_to_functions["retrieve_payment_status"](transaction_id="T1001")
```
